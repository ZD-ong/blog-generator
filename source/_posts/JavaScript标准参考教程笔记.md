---
title: JavaScript标准参考教程笔记
date: 2018-01-10 20:33:25
tags:
---
阅读阮一峰JavaScript标准参考教程的读书笔记，写下来，加深记忆。
# 语法
## 对象
### 1.1 生成对象
对象就是一组“键值对”（key-value）的集合，是一种无序的符合数据集合。
```
var obj = {
  foo: 'Hello',
  bar: 'World'
};
//第一个键值对是foo: 'Hello'，其中foo是“键名”（成员的名称），字符串Hello是“键值”（成员的值）
//键名与键值之间用冒号分隔
//两个键值对之间用逗号分隔
```
上面代码中，大括号定义了一个对象，被赋值给变量 `obj`，所以变量`obj`就指向一个对象。
### 1.2 键名
对象的所有键名都是字符串，所以加不加引号都可以。
日过键名是数值，会被自动转化为字符串。
```
var  obj = {
  1: 'A'，
  1e2: true
};
obj[1] //A
obj['1'] //A
```
上面代码中，对象`obj`的键名虽然看上去像数值，实际上被自动转成了字符串。
**如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符） 且也不是数字，则必须加上引号，否则会报错**
<!-- more -->
```
var obj = {
  1p: 'Hello World'
};
//报错
var obj = {
  '1p': 'Hello World',
  'h w': 'Hello World',
  'p+q': 'Hello World'
};
//不报错
```
不符合标识名条件的键名，必须加上引号。
对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。
```
var obj = {
  p: function(x){
    return 2 * x;
  }
};
obj.p(1)
//2
```
如果属性的值还是一个对象就形成了链式引用。
```
var o1 = {};
var o2 = {bar: 'hello'};

o1.foo = o2;
o1.foo.bar
//'hello'
```
上面代码中，对象`o1`的属性`foo`指向对象`o2`，就可以链式引用`o2`的属性。
属性可以动态创建，不必在对象声明时就指定。
```
var obj = {};
obj.foo = 123;
obj.foo
//123
```
上面代码中，直接对`obj`对象的`foo`属性赋值，结果就在运行时创建了`foo`属性。
### 1.3 对象的引用
如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有的变量。
如果取消某一个变量对于原对象的引用，不会影响到另一个变量。
```
var o1 = {};
var o2 = o1;

o1 = 1;
o2 // {}
```
上面代码中，`o1`和`o2`指向同一个对象，然后`o1`的值变为1，这时不会对`o2`产生影响，`o2`还是指向原来的那个对象。
但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。
```
var x = 1;
var y = x;

x = 2;
y // 1
```
上面代码中，当`x`的值发生变化后，`y`的值并不变，这就表示`y`和`x`并不是指向同一个内存地址。
### 1.4 表达式还是语句
对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底时表达式还是语句？
```
{foo: 123}
```
JavaScript引擎读到上面这行代码，会发现可能有两种含义。第一种，这是一个表达式，表示一个包含`foo`属性的对象；第二种是，这是一个语句，表示一个代码区块，里面有一个`foo`标签，指向表达式123。
**为避免歧义，JavaScript规定，如果行首是大括号，一律解释为语句（代码块）。如果解释为表达式（对象），必须在大括号前加上圆括号。**
### 2.1 读取属性
读取对象属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。
```
var obj = {
  p: 'Hello World'
};

obj.p // "Hello World"
obj['p'] // "Hello World"
```
**如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。**
```
var foo = 'bar';

var obj = {
  foo: 1,
  bar: 2
};

obj.foo  // 1
obj[foo]  // 2
```
方括号运算符内部还可以使用表达式。
数字键可以不加引号，因为会自动转成字符串。
**数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。**
### 2.2 属性的赋值
点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。
JavaScript允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候就定义好属性。
```
var obj = { p: 1 };

// 等价于

var obj = {};
obj.p = 1;
```
### 2.3 查看所有属性
查看一个对象本身所有的属性，可以用`Object.keys`方法。
```
Object.keys(obj);
//obj为对象
```
### 2.4 delete 命令
`delete`命令用于删除对象的属性，删除成功后返回`true`。
```
delete obj.p
//true
//删除obj对象的p属性
```
**删除一个不存在的属性，`delete`不报错，且返回`true`，所以不能根据`delete`命令的结果，认定某个属性是存在的。另，`delete`命令只能删除对象本身属性，无法删除继承的属性。**
（只有一种情况，`delete`命令返回`false`，那就是该元素存在，不得删除。）
### 2.5 in 运算
`in`运算符用于检查对象是否包含某个属性（键名），如果包含就返回`true`，否则返回`false`。
```
var obj = { p: 1 };
'p' in obj // true
```
`in`运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些是继承的。
### for...in 循环
`for...in`循环用来遍历一个对象的全部属性。
下面是一个使用`for...in`循环，提取对象属性名的例子。
```
var obj = {
  x: 1,
  y: 2
};
var props = [];
var i = 0;

for (var p in obj) {
  props[i++] = p
}

props // ['x', 'y']
```
**遍历的对象是所有可遍历的属性，会跳过不可遍历属性。（toString不可遍历）**
**不仅遍历自身的属性，还遍历继承的属性。**
结合`hasOwnProperty`方法使用，在循环内部判断一下，某个属性是否为自身属性。
```
obj.hasOwnProperty(key)
```
## 数组
### 1. 定义
数组是按照次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。
除了在定义时赋值，数组也可以先定义后赋值。
```
var arr = [];

arr[0] = 'a';
arr[1] = 'b';
arr[2] = 'c';
```
任何类型的数据，都可以放入数组。
```
var arr = [
  {a: 1},
  [1, 2, 3],
  function() {return true;}
];
```
如果数组的元素还是数组，就形成了多维数组。
```
var a = [[1, 2], [3, 4]];
a[0][1] // 2
a[1][1] // 4
```
### 2. 数组的本质
本质上，数组属于一种特殊的对象。
```
typeof [1, 2, 3] // "object"
```
数组的特殊性体现在，它的键名是按照次序排列的一组整数（0，1，2。。。）。
**对于数值键名，不能使用点结构**
```
var arr = [1, 2, 3];
arr.0 // SyntaxError
```
上面代码中，arr.0的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号arr[0]表示（方括号是运算符，可以接受数值）。
### 3. length 属性
数组的`length`属性，返回数组成员数量。
只要是数组，就一定有`length`属性。**该属性是一个动态的值，等于键名中最大整数加上1。**
数组是一种动态数据结构，可以随时增减数组成员。
`length`属性是可写的。
```
var arr = [ 'a', 'b', 'c' ];
arr.length // 3

arr.length = 2;
arr // ["a", "b"]
//该组成员自动减少到length设置的值
```
清空数组的方法，可以将`length`属性设为0。
*值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响length属性的值。*
### in运算符
检查某个键名是够存在的运算符`in`，适用于对象，也适用于数组。
### for...in 循环和数组的遍历
`for...in`循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。
但是，`for...in`不仅会遍历数组所有数字键，还会遍历非数字键。
```
var a = [1, 2, 3];
a.foo = true;

for (var key in a) {
  console.log(key);
}
// 0
// 1
// 2
// foo
```
所以不推荐使用`for...in`遍历数组。
可以考虑使用`for`循环或者`while`循环。
```
var a = [1, 2, 3];

// for循环
for(var i = 0; i < a.length; i++) {
  console.log(a[i]);
}

// while循环
var i = 0;
while (i < a.length) {
  console.log(a[i]);
  i++;
}

var l = a.length;
while (l--) {
  console.log(a[l]);
}
```
数组的`forEach`方法也可以用来遍历数组。
```
var colors = ['red', 'green', 'blue'];
colors.forEach(function (color) {
  console.log(color);
});
// red
// green
// blue
```
### 6. 数组的空位
当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位。
```
var a = [1, , 1];
a.length // 3
```
上面代码表明，数组的空位不影响length属性。
需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。
数组的空位是可以读取的，返回undefined。
```
var a = [, , ,];
a[1] // undefined
```
如果是空位，使用数组的forEach方法、for...in结构、以及Object.keys方法进行遍历，空位都会被跳过(undefined不会)。
### 7. 类数组对象
如果一个对象的所有键名都是正整数或零，并且有`length`属性，那么这个对象很像数组，语法上称为“类数组对象”。
遍历：可以将“类数组对象”转为真正额数组，然后直接调用`forEach`方法。
```
var arr = Array.prototype.slice.call('abc');
arr.forEach(function (chr) {
  console.log(chr);
});
// a
// b
// c
```
## 函数
函数是一段可以反复调用的代码块。
### 1. 概述
#### 1.1 函数的声明
JavaScript有三种声明函数的方法。
（1）function 命令
（2）函数表达式（采用变量赋值的写法）
```
var print = function(s) {
  console.log(s);
};
//此时匿名函数称为函数表达式
```
（3）Function 构造函数
```
var add = new Function(
  'x',
  'y',
  'return x + y'
);

// 等同于
function add(x, y) {
  return x + y;
}
```
不推荐此方法，了解即可。
#### 1.2 函数重复声明
如果一个函数被多次声明，后面的声明就会覆盖前面的声明。
#### 1.3 圆括号运算符，return 语句和递归
调用函数时。要使用圆括号运算符。圆括号中加入函数参数。
```
function add(x, y) {
  return x + y;
}

add(1, 1) // 2
```
上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。

函数体内部的`return`语句，表示返回。JavaScript 引擎遇到`return`语句，就直接返回`return`后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，`return`语句所带的那个表达式，就是函数的返回值。`return`语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回`undefined`。

函数调用自身就是递归（recursion）。
```
//计算斐波那契数列
function fib(num) {
  if (num === 0) return 0;
  if (num === 1) return 1;
  return fib(num - 2) + fib(num - 1);
}

fib(6) // 8
//fib函数内部又调用了fib，计算得到斐波那契数列的第6个元素是8。
```
#### 1.4 函数名的提升
JavaScrip 引擎将函数名视同变量名，所以采用`function`命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。
```
f();

function f() {}
```
由于变量提升，函数`f`被提升到代码头部，所以不会报错。
**如果采用赋值语句定义函数，会报错**
```
f();
var f = function (){};
// TypeError: undefined is not a function
```
等同于
```
var f;
f();
f = function () {};
//调用f时，f只是被声明，未赋值，等于undefined
```
**所以如果同时采用`function`命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。**
#### 1.5 不能在条件语句总声明函数
### 2. 函数的属性和方法
#### 2.1 name 属性
函数的name属性返回紧跟在function关键字之后的那个函数名。
```
function f1() {}
f1.name // 'f1'
//函数的name属性总是返回紧跟在function关键字之后的那个函数名
```
#### 2.2 length 属性
函数的`length`属性返回函数预期传入的参数个数（定义的参数个数）。
```
function f(a, b) {}
f.length // 2
```
#### 2.3 toString()
函数的`toString()`方法返回一个字符串，内容是函数源码。
```
function f() {/*
  这是一个
  多行注释
*/
  a();
  b();
  c();
}

f.toString()
// function f() {/*
//   这是一个
//   多行注释
//*/
//  a();
//  b();
//  c();
// }
```
### 3. 函数作用域
#### 3.1 定义
作用域指的是变量存在的范围。
全局作用域：变量在整个程序中一直存在，所有地方都可以读取（在函数外部声明）。
函数作用域：变量只在函数内部存在（在函数内部定义）。
块级作用域
**函数内部定义的变量，会在该作用域内覆盖同名全局变量。**
```
var v = 1;

function f(){
  var v = 2;
  console.log(v);
}

f() // 2
v // 1
```
**注意，对于`var`命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。**
```
if (true) {
  var x = 5;
}
console.log(x);  // 5
```
上面代码中，变量`x`在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。
### 3.2 函数内部的变量提升
与全局作用域一样，函数作用域内部也会产生“变量提升”现象。`var`命令声明的变量，不管在什么位置，变量声明都会被提升到函数体头部。
```
function foo(x) {
  if (x > 100) {
    var tmp = x - 100;//可以理解为这一区块声明的全局变量
  }//在这个区块又成为局部变量，因为在函数体中
}

// 等同于
function foo(x) {
  var tmp;
  if (x > 100) {
    tmp = x - 100;
  };
}
```
#### 3.3 函数本身的作用域
函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在作用域无关。
```
var a = 1;
var x = function () {
  console.log(a);
};

function f() {
  var a = 2;
  x();
}

f() // 1
```
上面代码中，函数`x`是在函数f的外部声明的，所以它的作用域绑定外层，内部变量`a`不会到函数`f`体内取值，所以输出`1`，而不是`2`。
**函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。**
**同样，函数体内声明的函数，作用域绑定函数体内部。**
### 4. 参数
#### 4.1 概述
函数运行时，有时候需要提供外部数据，不同的外部数据会得到不同结果，这种外部数据就叫做参数。
```
function square(x) {
  return x * x;
}

square(2) // 4
square(3) // 9
```
参数可省略。
```
function f(a, b) {
  return a;
}

f(1, 2, 3) // 1
f(1) // 1
f() // undefined

f.length // 2
```
#### 4.2 同名参数
如果有同名参数，则取最后出现的那个值。
```
function f(a, a) {
  console.log(a);
}

f(1, 2) // 2
```
调用函数`f`时，没有提供第二个参数，`a`的值就变成了`undefined`。
```
function f(a, a) {
  console.log(a);
}

f(1) // undefined
```
#### 4.3 arguments 对象
由于 JavaScript 允许函数有不定数目的参数。所以需要一种机制，可以在函数体内部读取所有参数，这就是`arguments`对象。
`arguments`对象包含了函数运行时的所有参数，`arguments[0]`就是第一个参数，`arguments[1]`就是第二个参数，以此类推。
**这个对象只有在函数体内部才能使用。**
```
var f = function (one) {
  console.log(arguments[0]);
  console.log(arguments[1]);
  console.log(arguments[2]);
}

f(1, 2, 3)
// 1
// 2
// 3
```
通过`arguments`对象的`length`属性，可以判断函数调用时到底带几个参数。
```
function f() {
  return arguments.length;
}

f(1, 2, 3) // 3
f(1) // 1
f() // 0
```
将`arguments`转为真正的数组
```
//slice方法
var args = Array.prototype.slice.call(arguments);

// 逐一填入数组
var args = [];
for (var i = 0; i < arguments.length; i++) {
  args.push(arguments[i]);
}
```
### 5. eval命令
eval命令的作用是，将字符串当作语句执行。
（此处不做过多介绍）
## 运算符
### 1. 加法运算符
#### 1.1 基本规则
- 数值求和
- 布尔值转数值求和
- 字符串拼接

运算子（数值，字符串）的不同，导致了不同的语法行为，这种现象称为“重载”（overload）。
加法运算符存在重载，需注意：
```
'3' + 4 + 5 // "345"
3 + 4 + '5' // "75"
```
由于由左到右运算，字符串的位置不同会导致不同的结果。
**除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。**
#### 1.2 对象的相加
如果运算子是对象，必须先转成原始类型的值，然后再相加。
```
var obj = { p: 1 };
obj + 2 // "[object Object]2"
```
对象转原始类型的值：
1. 调用对象valueOf方法（返回对象自身）
```
var obj = { p: 1 };
obj.valueOf() // { p: 1 }
```
2. 调用对象toString方法（转为字符串）
```
var obj = { p: 1 };
obj.valueOf().toString() // "[object Object]"
//对象的toString方法默认返回[object Object]
```
这里有一个特例，如果运算子是一个Date对象的实例，那么会优先执行toString方法。
```
var obj = new Date();
obj.valueOf = function () { return 1 };
obj.toString = function () { return 'hello' };

obj + 2 // "hello2"
```
toString方法优先执行。
### 2. 算数运算符
#### 2.1 余数运算符
运算结果的正负号由第一个运算子的正负号决定。
```
-1 % 2 // -1
1 % -2 // 1
```
为了得到负数的正确余数值，可以先使用绝对值函数.
```
function isOdd(n) {
  return Math.abs(n % 2) === 1;
}
isOdd(-5) // true
isOdd(-4) // false
```
#### 2.2 自增自减运算符
自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。
```
var x = 1;
var y = 1;

x++ // 1
++y // 2
```
上面代码中，x是先返回当前值，然后自增，所以得到1；y是先自增，然后返回新的值，所以得到2。
#### 2.3 数值运算符，负数值运算符
数值运算符的作用在于可以将任何值转为数值（与Number函数的作用相同）。
```
+true // 1
+[] // 0
+{} // NaN
```
负数值运算符（-），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符，等同于数值运算符。
```
var x = 1;
-x // -1
-(-x) // 1
```
**数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值。**
### 4. 比较运算符
#### 4.1 字符串的比较
字符串按照字典顺序进行比较。
```
'cat' > 'dog' // false
'cat' > 'catalog' // false
```
JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。
#### 4.2 非字符串的比较
##### 4.2.1 原始类型的值
两个原始类型的值的比较，除了相等运算符（==）和严格相等运算符（===），其他比较运算符都是先转成数值再比较。

任何值（包括NaN本身）与NaN比较，返回的都是false。
##### 4.2.2 对象
如果运算子是对象，会转为原始类型的值，再进行比较。
#### 4.3 严格相等运算符
两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。
```
var v1 = {};
var v2 = v1;
v1 === v2 // true
```
**注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值**

undefined和null与自身严格相等。
undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。

由于变量声明后默认值是undefined，因此两个只声明未赋值的变量是相等的。
### 5. 布尔运算符
#### 5.1 取反运算符
对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。
```
!undefined // true
!null // true
!false //true
!0 // true
!NaN // true
!"" // true

!54 // false
!'hello' // false
![] // false
!{} // false
```
不管什么类型的值，经过取反运算后，都变成了布尔值。
#### 5.2且运算符（&&）
如果第一个运算子的布尔值为true，则返回第二个运算子的值（注意是值，不是布尔值）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。
#### 5.3或运算符（||）
如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。

或运算符常用于为一个变量设置默认值。
```
function saveText(text) {
  text = text || '';
  // ...
}

// 或者写成
saveText(this.text || '')
```
上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串。
#### 5.4 三元运算符（?:）
与`if...else...`的区别：
if...else是语句，没有返回值；三元条件表达式是表达式，具有返回值。
所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用if..else。
### 6. 位运算
### 7. 其他运算符
### 8. 运算顺序
#### 8.1 优先级
记住所有运算符优先级，没有必要，查阅即可。
## 数据类型转换
### 1. 强制转换
强制转换主要指使用Number、String和Boolean三个函数，手动将各种类型的值，分布转换成数字、字符串或者布尔值。
#### 1.1 Number()
Number函数将字符串转为数值，要比parseInt函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为NaN。
```
parseInt('42 cats') // 42
Number('42 cats') // NaN
```
上面代码中，parseInt逐个解析字符，而Number函数整体转换字符串的类型。
Number方法的参数是对象时，将返回NaN，除非是包含单个数值的数组。
#### 1.2 String()
String方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。
```
String({a: 1}) // "[object Object]"
String([1, 2, 3]) // "1,2,3"
```
#### 1.3 Boolean()
它的转换规则相对简单：除了以下五个值的转换结果为false，其他的值全部为true。
```
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean(NaN) // false
Boolean('') // false
```
**所有对象的布尔值都是true**
### 2. 自动转换
- 不同类型的数据互相运算
```
123 + 'abc' // "123abc"
```
- 非布尔值类型的数据求布尔值
```
if ('abc') {
  console.log('hello')
}  // "hello"
```
- 对非数值类型的值使用一元运算符（即+和-）
```
+ {foo: 'bar'} // NaN
- [1, 2, 3] // NaN
```
## 标准库
