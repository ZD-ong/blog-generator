---
title: 图解HTTP笔记
date: 2018-01-15 00:59:00
tags: HTTP 笔记 TCP IP DNS
---
# 第一章 了解 Web 及网络基础
## 使用 HTTP 协议访问 Web
当我们在浏览器地址输入 URL 敲下回车，根据 Web 浏览器地址栏中指定的URL，Web 浏览器从 Web 服务器端获取文件资源（resource）等信息，从而显示出 Web 页面。
从客户端到服务器端等一系列运作流程，使用的就是HTTP协议。
Web 是建立在 HTTP 协议上通信的。
## HTTP 的诞生
1989年3月，HTTP 诞生了。
CERN（欧洲核子研究组织）的蒂姆 • 伯纳斯 - 李（Tim BernersLee）- 李爵士
提出了3项 WWW 构建技术
1. HTML
2. HTTP
3. URL

## 网络基础 TCP/IP
通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。
计算机与网络设备要相互通信，双方就必须基于同样的方法，遵守同样的规则，这个规则就叫做协议。
互联网相关联的协议集合起来总称为 TCP/IP。
<!--more-->
TCP/IP 协议族里重要的一点就是分层。TCP/IP 协议族按层次分别分为以下 4 层：应用层、传输层、网络层和数据链路层。
（由于未在书中得到关于应用层更好的解释，为了方便理解，[参考阮一峰博客](http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html)）

1. 应用层：应用层会收到“传输层”的数据进行解读，规定应用程序的数据格式（HTTP也处于这一层）
2. 传输层：对上层应用层，提供处于网络链接中的两台计算机之间的数据传输。
3. 网络层：处理网络上流动的数据包。（数据包是网络传输的最小数据单位）该层规定了通过怎样的路径（传输路线）到达对方的计算机，并把数据包传送给对方。（如果需要通过多台计算机或网络设备传输，网络层的作用就是在众多选项里选择一条传输路线）
4. 链路层
用来处理连接网络的硬件部分。（硬件上的范畴均在链路层的作用范围内）
![TCP/IP 通信传输流](https://i.loli.net/2018/01/14/5a5b7b1fd2f6d.png)
利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则从链路层往上走。
![TCP/IP 通信传输流](https://i.loli.net/2018/01/14/5a5b7c638ddbc.png)
发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。

## 与 HTTP 关系密切的协议 : IP 和 TCP
- IP 网际协议位于网络层，作用是把各种数据包传送给对方。为了确保数据能够准确传送，则需要满足一些条件，IP 地址和 Mac 地址。
IP 地址是指节点被分配到的地址（可更换），Mac 地址指网卡所属的固定地址（不会更改）。
- TCP 协议位于传输层，将数据节流（将大块数据分割管理），能够将数据准确可靠的传达。
TCP 的三次握手（TCP 协议能够确认数据是否送达）
发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。
![TCP的三次握手](https://i.loli.net/2018/01/15/5a5b82c66173b.png)

## 负责域名解析的 DNS 服务
DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。
- 用户：通常使用域名访问对方计算机，而不是通过 IP 地址。（语义化）
- 计算机：更擅长处理数字（IP地址），而不是域名。

为了解决这一问题，DNS 服务诞生了。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。
## 各种协议与 HTTP 协议的关系
![输入URL之后发生了什么](https://i.loli.net/2018/01/15/5a5b86194b932.png)
## URI 和 URL
URI 用字符串标识某一互联网资源，而 URL 表示资源的地点（互联网上所处的位置）。可见 URL 是 URI 的子集。
![URI 格式](https://i.loli.net/2018/01/15/5a5b890ddf1ce.png)
通过 URL 你可以确定一个唯一的网址。
# 第二章 简单的 HTTP 协议
## HTTP 协议用于客户端和服务器之间的通信
请求访问文本或图像等资源的一端称为客户端，而提供资源响应的一端称为服务器。
## 通过请求和响应的交换达成通信
![请求必定由客户端发出，而服务器端回复响应](https://i.loli.net/2018/01/15/5a5cbe1d5e861.png)
下面是从客户端发给某个 HTTP 服务器端的请求报文
```
GET /index.html HTTP/1.1
Host: hackr.jp
```
- `GET`: 表示请求访问服务器的类型（方法）
- `/index`: 请求访问的资源对象，也叫做请求 URL
- `HTTP/1.1`: HTTP的版本号

以上报文可以理解为：请求访问某台 HTTP 服务器上的 `/index.html` 页面资源。
请求报文由请求方法、请求  URL、协议版本、可选的请求首部字段和内容实体构成。
![请求报文的构成](https://i.loli.net/2018/01/15/5a5cbffa1c123.png)
接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。
```
HTTP/1.1 200 OK
Date: Tue, 10 Jul 2012 06:50:15 GMT
Content-Length: 362
Content-Type: text/html

<html>
……
</html>
```
- `HTTP/1.1`: 服务器对应的 HTTP 版本
- `200 OK`: 请求处理结果的状态码和原因短语
- `<html>......</html>`: 资源实体的主体
![响应报文的构成](https://i.loli.net/2018/01/15/5a5cc15e03c45.png)

## HTTP 是不保存状态的协议
HTTP：无状态协议。（HTTP 协议自身不对请求和响应之间的通信状态进行保存）
![HTTP 协议自身不具备保存之前发送过的请求或响应的功能](https://i.loli.net/2018/01/15/5a5cc212b47a9.png)
HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。(管理通信状态)

## 请求 URI 定位资源
![指定请求 URI 的方式](https://i.loli.net/2018/01/15/5a5cc33852bea.png)
如果不是访问特定资源而是对服务器本身发去请求，可以用一个`*`来代替请求 URL。
```
OPTIONS * HTTP/1.1
//查询 HTTP 服务器端支持的 HTTP 方法种类
```
## 告知服务器意图的 HTTP 方法
HTTP/1.1 中可使用的方法
- `GET`: 获取资源
- `POST`: 传输实体主体（和`GET`比，主要目的并不是获取响应的主体内容）
- `PUT`: 传输文件（在请求报文的主体中包含文件内容，然后保存到请求 URI 指定位置，存在安全性问题）
- `HEAD`: 和 `GET`方法类似，但不返回报文主体部分。用于确认 URI 的有效性及资源更新时间等。
- `DELETE`: 删除文件（按请求 URI 删除指定资源，存在安全性问题）
- `OPTIONS`: 询问支持的方法
- `TRACE`: 追踪路径（让 Web 服务器端将之前的请求通信返回给客户端的方法）
- `CONNECT`: 要求用隧道协议连接代理（要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信）

## 使用方法下达命令
向请求 URI 指定的资源发送请求报文时，采用称为方法的命令。
方法的作用在于，可以指定请求的资源按期望产生某种行为。（方法中有 GET、POST 和 HEAD 等）
## 持久连接节省通信量
发送请求一份包含多张图片的HTML文档对应的Web页面，会产生大量的通信开销（多次请求，不断的建立连接、断开连接）
为解决上述 TCP 连接的问题，衍生了持久连接的方法。
- 持久连接：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。（建立一次连接，多次请求和响应）
**在 HTTP/1.1 中，所有的连接默认都是持久连接**
- 管线化：不用等待响应亦可直接发送下一个请求（同时并行发送多个请求，而不需要一个接一个地等待响应）。
管线化技术则比持久连接还要快。

## 使用 Cookie 的状态管理
之前提到了，HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。
![如果让服务器管理全部客户端状态则会成为负担](https://i.loli.net/2018/01/15/5a5ccc66eea1a.png)
Cookie: 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。
1. Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。
 ```
HTTP/1.1 200 OK
Date: Thu, 12 Jul 2012 07:12:20 GMT
Server: Apache
＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,
10-Oct-12 07:12:20 GMT＞
Content-Type: text/plain; charset=UTF-8
```
2. 当客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。
```
GET /image/ HTTP/1.1
Host: hackr.jp
Cookie: sid=1342077140226724
```
3. 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。
![Cookie 交互场景](https://i.loli.net/2018/01/15/5a5ccdf578ad0.png)

# 第三章 HTTP 报文内的 HTTP 信息
## HTTP 报文
用于 HTTP 协议交互的信息被称为 HTTP 报文。
![HTTP 报文的结构](https://i.loli.net/2018/01/16/5a5cd21050cbe.png)
## 请求报文及响应报文的结构
![请求报文（上）和响应报文（下）的实例](https://i.loli.net/2018/01/16/5a5cd2fa4d397.png)
```
//请求的格式
1 动词 路径 协议/版本
2 Key1: value1
2 Key2: value2
2 Key3: value3
2 Content-Type: application/x-www-form-urlencoded
2 Host: www.baidu.com
2 User-Agent: curl/7.54.0
3 
4 要上传的数据
```
- 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空）
- 第三部分永远都是一个回车（\n）
- 动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等
- 这里的路径包括「查询参数」，但不包括「锚点」
- 如果你没有写路径，那么路径默认为 /
- 第 2 部分中的 Content-Type 标注了第 4 部分的格式

## 编码提升传输速率
HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率（优：有效地处理大量的访问请求。缺：消耗更多的 CPU 等资源）。

1. 内容编码：应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。
常用的内容编码：
    - gzip（GNU zip）
    - compress（UNIX 系统的标准压缩）
    - deflate（zlib）
    - identity（不进行编码）
2. 分块传输编码：在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据（实体主题）分割成多块，能够让浏览器逐步显示页面。

## [发送多种数据的多部分对象集合](http://www.ituring.com.cn/book/miniarticle/74639)
## [获取部分内容的范围请求](http://www.ituring.com.cn/book/miniarticle/74640)
## 内容协商返回最合适的内容
我们会遇到一些支持多语言的网站，浏览器会根据默认语言显示相对应的网页，这样的机制称为内容协商。
内容协商机制：是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。
内容协商技术有以下 3 种类型
- 服务器驱动协商：服务器端参考请求首部字段自动处理。
- 客户端驱动协商：用户手动选择。
- 透明协商：服务器端和客户端各自进行内容协商。

# 第四章 返回结果的 HTTP 状态码
## 状态码告知从服务器端返回的请求结果
状态码如 200 OK，以 3 位数字和原因短语组成。
![状态码的类别](https://i.loli.net/2018/01/16/5a5e11fd95ac5.png)
## 2XX 成功
2XX 的响应结果表明请求被正常处理了。
- 200 OK：表示从客户端发来的请求在服务器端被正常处理了。
- 204 No Content：请求处理成功，但无资源返回。（浏览器发出请求，页面不发生更新）
- 206 Partial Content：发出了获取部分资源的请求，服务器成功处理该请求，返回指定范围的实体内容（Content-Range）。

## 3XX 重定向
3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。
- 301 Moved Permanently：永久性重定向。请求的资源已被分配了新的 URL 。（比如已经把对应资源 URL 保存为书签，这时应该按 Location 首部字段提示的 URL 重新保存，资源被永久性移动。）
- 302 Found：暂时性重定向。请求的资源已经被分配了新的 URL 希望用户（本次）能使用新的 URL 访问。（资源不是被永久性移动）
- 303 See Other：由于请求的资源存在另一个 URL ，应使用 GET 方法定向获取请求的资源。
- 304 Not Modified：客户端发送附带条件的请求时，服务器允许请求访问资源，但因发生的请求未满足条件的情况，直接返回304 Not Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）
- 307 Temporary Redirect
临时重定向。与302有着相同的含义。

## 4XX 客户端错误
4XX 的响应结果表明客户端是发生错误的所在。
- 400 Bad Request：请求报文存在语法错误。（需要修改请求的内容后再发送）
- 401 Unauthorized：发送的请求需要有通过
 HTTP 认证的认证信息。（浏览器初次接收到401响应会弹出认证窗口，第二次则表示认证失败。）
- 403 Forbidden：对请求资源的访问被服务器拒绝了。（未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。）
- 404 Not Found：服务器上无法找到请求的资源。（服务端拒接请求且不想说明原因时也可能返回404）

## 5XX 服务器错误
- 500 Internal Sever Error：服务器在执行请求时发生了错误。
- 503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，无法处理请求。

返回的状态码也有可能出错。
# 第五章 与 HTTP 协作的 Web 服务器
## 用单台虚拟主机实现多个域名
即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器。

通常客户端访问服务器，会采用域名访问，域名通过 DNS 服务映射到 IP 地址(域名解析)后访问目标网站。所以，当请求发送到服务器时，已经是以 IP 地址形式访问了。

如果一台服务器托管了两个域名，当收到请求时就需要弄清楚要访问哪个域名。
![一台托管了两个域名的服务器](https://i.loli.net/2018/01/17/5a5f6ec1270ef.png)
所以，相同 IP 地址下，通过虚拟主机可以寄存多个不同的主机名和域名的网站，因此**在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名 URI。**
## 通信数据转发程序：代理、网关、隧道
HTTP 通信时，不光是客户端和服务器之间的协作，还有一些配合服务器工作的应用程序，例如代理、网关和隧道。
- 代理：具有转发功能，接收客户端的请求转发给服务器，同时接收服务器的响应转发给客户端。
代理服务器可以利用缓存技术减少网络带宽的流量（保存资源副本，当再次接到相同资源请求，直接将缓存资源返回），添加对特定网站的访问控制等。
- 网关：接收从客户端发送来的请求时，就像自己拥有资源的源服务器一样对请求进行处理。
![利用网关可以由 HTTP 请求转化为其他协议通信](https://i.loli.net/2018/01/17/5a5f72e42cc5d.png)
在客户端和网关间的通信路线上加密能提高通信的安全性（网关可以连接数据库）。
- 隧道：在客户端和服务器两者之间进行中转，保持双方通信连接。
![通过隧道的传输，可以和远距离的服务器安全通信。隧道本身是透明的，客户端不用在意隧道的存在](https://i.loli.net/2018/01/18/5a5f73f5d5f2d.png)
隧道的目的是确保客户端能与服务器进行安全的通信（使用 SSL 等加密手段）。

## 保存资源的缓存
缓存是指代理服务器或客户端本地磁盘内保存的资源副本。


缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求了。
### 缓存的有效期限
如果源服务器上的资源更新，还使用不变的缓存就相当于直接返回“旧”资源了。
![缓存代理向源服务器确认缓存有效性](https://i.loli.net/2018/01/18/5a5f763941b45.png)
所以缓存代理会向源服务器确认资源的有效性，若判断缓存失效，缓存代理会重新获取“新”资源。
### 客户端的缓存
浏览器缓存（临时网络文件）如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。
同样的，当判断缓存失效会重新请求新资源。
![浏览器向源服务器确认缓存有效性](https://i.loli.net/2018/01/18/5a5f76ff31809.png)


